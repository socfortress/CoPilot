<template>
    <div class="vulnerability-reports">
        <div class="header mb-6 flex items-center justify-between">
            <div>
                <h2 class="text-2xl font-bold mb-2">Vulnerability Reports</h2>
                <p class="text-secondary">Generate, manage, and download vulnerability reports</p>
            </div>
            <n-button type="primary" size="large" @click="showGenerateModal = true">
                <template #icon>
                    <Icon :name="AddIcon" />
                </template>
                Generate Report
            </n-button>
        </div>

        <!-- Filters -->
        <n-card class="mb-6">
            <div class="flex gap-4">
                <n-select
                    v-model:value="filterCustomerCode"
                    :options="customerOptions"
                    placeholder="Filter by Customer"
                    clearable
                    filterable
                    class="flex-1"
                    @update:value="loadReports"
                />
                <n-button @click="loadReports" :loading="loading">
                    <template #icon>
                        <Icon :name="RefreshIcon" />
                    </template>
                    Refresh
                </n-button>
            </div>
        </n-card>

        <!-- Reports Table -->
        <n-card>
            <n-data-table
                :columns="columns"
                :data="reports"
                :loading="loading"
                :pagination="pagination"
                :row-key="(row: VulnerabilityReport) => row.id"
            />
        </n-card>

        <!-- Generate Report Modal -->
        <n-modal
            v-model:show="showGenerateModal"
            preset="card"
            title="Generate Vulnerability Report"
            class="max-w-2xl"
            :closable="true"
        >
            <GenerateReportForm
                :customers="customers"
                :loading="generating"
                @generate="handleGenerateReport"
                @cancel="showGenerateModal = false"
            />
        </n-modal>

        <!-- Delete Confirmation Modal -->
        <n-modal
            v-model:show="showDeleteModal"
            preset="dialog"
            title="Delete Report"
            :positive-text="'Delete'"
            :negative-text="'Cancel'"
            @positive-click="confirmDelete"
            @negative-click="showDeleteModal = false"
        >
            <p>Are you sure you want to delete the report "{{ reportToDelete?.report_name }}"?</p>
            <p class="text-secondary mt-2">This action cannot be undone.</p>
        </n-modal>
    </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed, h } from "vue"
import { NCard, NButton, NDataTable, NModal, NSelect, NTag, NTooltip, NSpace, useMessage, type DataTableColumns } from "naive-ui"
import type { VulnerabilityReport, VulnerabilityReportGenerateRequest } from "@/types/vulnerabilities.d"
import Api from "@/api"
import Icon from "@/components/common/Icon.vue"
import GenerateReportForm from "./GenerateReportForm.vue"
import { formatDate, formatBytes } from "@/utils/format"

const AddIcon = "carbon:document-add"
const RefreshIcon = "carbon:renew"
const DownloadIcon = "carbon:download"
const DeleteIcon = "carbon:trash-can"
const CheckIcon = "carbon:checkmark-filled"
const ErrorIcon = "carbon:warning-filled"
const LoadingIcon = "eos-icons:loading"

const message = useMessage()

const loading = ref(false)
const generating = ref(false)
const reports = ref<VulnerabilityReport[]>([])
const showGenerateModal = ref(false)
const showDeleteModal = ref(false)
const reportToDelete = ref<VulnerabilityReport | null>(null)
const filterCustomerCode = ref<string | null>(null)
const customers = ref<Array<{ label: string; value: string }>>([])

const customerOptions = computed(() => [
    ...customers.value
])

const pagination = {
    pageSize: 20,
    showSizePicker: true,
    pageSizes: [10, 20, 50, 100]
}

const columns: DataTableColumns<VulnerabilityReport> = [
    {
        title: "Report Name",
        key: "report_name",
        ellipsis: {
            tooltip: true
        }
    },
    {
        title: "Customer",
        key: "customer_code",
        width: 120
    },
    {
        title: "Status",
        key: "status",
        width: 120,
        render: (row: VulnerabilityReport) => {
            const statusMap = {
                completed: { type: "success", icon: CheckIcon, text: "Completed" },
                processing: { type: "warning", icon: LoadingIcon, text: "Processing" },
                failed: { type: "error", icon: ErrorIcon, text: "Failed" }
            }
            const status = statusMap[row.status]
            return h(
                NTag,
                { type: status.type as any, size: "small" },
                {
                    default: () => status.text,
                    icon: () => h(Icon, { name: status.icon, size: "14" })
                }
            )
        }
    },
    {
        title: "Vulnerabilities",
        key: "total_vulnerabilities",
        width: 140,
        render: (row: VulnerabilityReport) => {
            return h(
                NTooltip,
                {},
                {
                    trigger: () => row.total_vulnerabilities.toLocaleString(),
                    default: () => h("div", {}, [
                        h("div", {}, `Critical: ${row.critical_count}`),
                        h("div", {}, `High: ${row.high_count}`),
                        h("div", {}, `Medium: ${row.medium_count}`),
                        h("div", {}, `Low: ${row.low_count}`)
                    ])
                }
            )
        }
    },
    {
        title: "File Size",
        key: "file_size",
        width: 120,
        render: (row: VulnerabilityReport) => formatBytes(row.file_size)
    },
    {
        title: "Generated",
        key: "generated_at",
        width: 180,
        render: (row: VulnerabilityReport) => formatDate(row.generated_at)
    },
    {
        title: "Actions",
        key: "actions",
        width: 140,
        render: (row: VulnerabilityReport) => {
            return h(
                NSpace,
                { size: "small" },
                {
                    default: () => [
                        row.status === "completed"
                            ? h(
                                    NButton,
                                    {
                                        size: "small",
                                        type: "primary",
                                        onClick: () => handleDownload(row)
                                    },
                                    {
                                        icon: () => h(Icon, { name: DownloadIcon })
                                    }
                              )
                            : null,
                        h(
                            NButton,
                            {
                                size: "small",
                                type: "error",
                                onClick: () => handleDeleteClick(row)
                            },
                            {
                                icon: () => h(Icon, { name: DeleteIcon })
                            }
                        )
                    ]
                }
            )
        }
    }
]

async function loadReports() {
    loading.value = true
    try {
        const response = await Api.vulnerabilities.listReports(filterCustomerCode.value || undefined)
        if (response.data.success) {
            reports.value = response.data.reports
        } else {
            message.error(response.data.message || "Failed to load reports")
        }
    } catch (error: any) {
        message.error(error?.response?.data?.detail || "Failed to load reports")
    } finally {
        loading.value = false
    }
}

async function loadCustomers() {
    try {
        // Try the customers API endpoint
        const response = await Api.customers.getCustomers()

        // Handle different possible response structures
        let customerData = response.data

        // If response.data is wrapped in a data property
        if (customerData.data) {
            customerData = customerData.data
        }

        // If it's an array, map it
        if (Array.isArray(customerData)) {
            customers.value = customerData.map((c: any) => ({
                label: `${c.customer_name || c.name || c.customer_code} (${c.customer_code})`,
                value: c.customer_code
            }))
        } else if (customerData.customers && Array.isArray(customerData.customers)) {
            // If customers are in a customers property
            customers.value = customerData.customers.map((c: any) => ({
                label: `${c.customer_name || c.name || c.customer_code} (${c.customer_code})`,
                value: c.customer_code
            }))
        } else {
            console.warn("Unexpected customer data structure:", customerData)
            message.warning("Customer data format unexpected")
        }

        console.log("Loaded customers:", customers.value)
    } catch (error: any) {
        console.error("Failed to load customers:", error)
        message.error("Failed to load customers list")
    }
}

async function handleGenerateReport(request: VulnerabilityReportGenerateRequest) {
    generating.value = true
    try {
        // Use background generation for better UX
        const response = await Api.vulnerabilities.generateReportBackground(request)

        if (response.data.success) {
            message.success(response.data.message)
            showGenerateModal.value = false

            // Add the new processing report to the list
            await loadReports()

            // Start polling for status updates
            startStatusPolling(response.data.report_id)
        } else {
            message.error("Failed to queue report generation")
        }
    } catch (error: any) {
        message.error(error?.response?.data?.detail || "Failed to generate report")
    } finally {
        generating.value = false
    }
}

function startStatusPolling(reportId: number) {
    const pollInterval = setInterval(async () => {
        try {
            await loadReports()

            const report = reports.value.find(r => r.id === reportId)
            if (report && report.status !== "processing") {
                clearInterval(pollInterval)

                if (report.status === "completed") {
                    message.success(`Report "${report.report_name}" completed successfully`)
                } else if (report.status === "failed") {
                    message.error(`Report "${report.report_name}" failed: ${report.error_message}`)
                }
            }
        } catch (error) {
            clearInterval(pollInterval)
        }
    }, 3000) // Poll every 3 seconds

    // Stop polling after 5 minutes
    setTimeout(() => clearInterval(pollInterval), 300000)
}

async function handleDownload(report: VulnerabilityReport) {
    try {
        const response = await Api.vulnerabilities.downloadReport(report.id)

        // Create download link
        const url = window.URL.createObjectURL(new Blob([response.data]))
        const link = document.createElement("a")
        link.href = url
        link.setAttribute("download", report.file_name)
        document.body.appendChild(link)
        link.click()
        link.remove()
        window.URL.revokeObjectURL(url)

        message.success("Report downloaded successfully")
    } catch (error: any) {
        message.error(error?.response?.data?.detail || "Failed to download report")
    }
}

function handleDeleteClick(report: VulnerabilityReport) {
    reportToDelete.value = report
    showDeleteModal.value = true
}

async function confirmDelete() {
    if (!reportToDelete.value) return

    try {
        const response = await Api.vulnerabilities.deleteReport(reportToDelete.value.id)

        if (response.data.success) {
            message.success(response.data.message)
            await loadReports()
        } else {
            message.error("Failed to delete report")
        }
    } catch (error: any) {
        message.error(error?.response?.data?.detail || "Failed to delete report")
    } finally {
        showDeleteModal.value = false
        reportToDelete.value = null
    }
}

onMounted(() => {
    loadReports()
    loadCustomers()
})
</script>

<style scoped>
.vulnerability-reports {
    padding: 20px;
}
</style>
